[{"authors":["admin"],"categories":null,"content":"- üë∂ Born in June, 2000\n- üè´ Currently Studying Computer Science at SFU\n- üéº Piano Enthusiast\n- üì∑ A Beginner Photographer\n- üíô Dota2, Board Game, Basketball\n- üíΩ Favorite Album: Êú®È©¨„ÄäÊûúÂÜªÂ∏ùÂõΩ„Äã\n- üé≤ Favorite Board Game: The Resistance: Avalon\n- üèÜ Favorite Sports Teams: PSG.LGD, Boston Celtics\n- üëΩ One speechless fact: A friend who did not want to be named said that my portrait photo was taken according to this alien expression.\n","date":1618012800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1618012800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"- üë∂ Born in June, 2000 - üè´ Currently Studying Computer Science at SFU - üéº Piano Enthusiast - üì∑ A Beginner Photographer - üíô Dota2, Board Game, Basketball - üíΩ Favorite Album: Êú®È©¨„ÄäÊûúÂÜªÂ∏ùÂõΩ„Äã - üé≤ Favorite Board Game: The Resistance: Avalon - üèÜ Favorite Sports Teams: PSG.LGD, Boston Celtics - üëΩ One speechless fact: A friend who did not want to be","tags":null,"title":"Yilin(Alex) Wang","type":"authors"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"Compiler of C-like language Decaf. Github Link\rHere is an example Decaf program:\nextern func print_int(int) void; package GreatestCommonDivisor { var a int = 10; var b int = 20; func main() int { var x, y, z int; x = a; y = b; z = gcd(x, y); // print_int is part of the standard input-output library print_int(z); } // function that computes the greatest common divisor func gcd(a int, b int) int { if (b == 0) { return(a); } else { return( gcd(b, a % b) ); } } }  Usage To create the default program, go to the answer directory and type in make default. To run the default program against the testcases, run the following commands:\n$ python zipout.py -r default $ python check.py  The output files are saved to the output directory while all the intermediate LLVM files created for each input Decaf program are saved to the llvm directory.\nDirectory dev_llvm contains sample output LLVM assembly for each Decaf program in testcases/dev. You can check that your output LLVM assembly is roughly doing the right thing by comparing your output to this sample output.\nHere are several shell scripts that helps streamline parts of the process.\n   Attempt description args output     build.sh Builds the project and runs against testcases in testcases directory. 0 None   evaluate.sh Compares all the project\u0026rsquo;s output files in output directory against the given references in reference directory to find any failing tests, and where the difference occurs. 0 None if all outputs are correct, file name and position of difference if failure occurred.   result.sh Provides outputs for user to compare their output against the reference output, as well as the used test case. file names without extension Provides the project\u0026rsquo;s original test case, reference output, and the project\u0026rsquo;s output.    Several use-case examples of the scripts are in README.md in directory scripts.\nProgram  makefile: contains the necessary recipes for building LLVM assembly code, C++ code using LLVM API calls and Lex/Yacc programs that use the LLVM API. decaf-stdlib.c: the Decaf standard library. Contains the extern functions used commonly in Decaf programs. Solution files:  default-defs.h: the common header file among all the default files decafcomp.cc: classes for LLVM code generation decafcomp.lex: the lexer for Decaf decafcomp.y: the yacc program for a small fragment of Decaf which uses decafcomp.cc for LLVM code generation.   llvm-run: the Python program used by check.py in order to run a Decaf program using the following steps. Each step assumes some file names but can be changed using command line options so run llvm-run -h to see the options and also read the source code of llvm-run to understand what it is doing. Stages are:  llvm: source code to LLVM code generation bc: assembly to LLVM bitcode s: bitcode to native code exec: linking to make native executable run: running the final executable    Implemented Grammar Lexer The lexical analyzer produces a stream of tokens for a given Decaf program. The input is taken from stdin (standard input) and the output token stream is sent to stdout (standard output). Errors are issued on the stderr (standard error) stream.\nThe lexical analyzer produces the following token stream:\nT_AND \u0026amp;\u0026amp; T_ASSIGN = T_BOOLTYPE bool T_BREAK break T_CHARCONSTANT char_lit (see section on Character literals) T_COMMA , T_COMMENT comment T_CONTINUE continue T_DIV / T_DOT . T_ELSE else T_EQ == T_EXTERN extern T_FALSE false T_FOR for T_FUNC func T_GEQ \u0026gt;= T_GT \u0026gt; T_ID identifier (see section on Identifiers) T_IF if T_INTCONSTANT int_lit (see section on Integer literals) T_INTTYPE int T_LCB { T_LEFTSHIFT \u0026lt;\u0026lt; T_LEQ \u0026lt;= T_LPAREN ( T_LSB [ T_LT \u0026lt; T_MINUS - T_MOD % T_MULT * T_NEQ != T_NOT ! T_NULL null T_OR || T_PACKAGE package T_PLUS + T_RCB } T_RETURN return T_RIGHTSHIFT \u0026gt;\u0026gt; T_RPAREN ) T_RSB ] T_SEMICOLON ; T_STRINGCONSTANT string_lit (see section on String literals) T_STRINGTYPE string T_TRUE true T_VAR var T_VOID void T_WHILE while T_WHITESPACE whitespace (see section on Whitespace)  Parser The parser of the compiler produces an abstract syntax tree for valid Decaf programs.\nAn abstract syntax tree (AST) is a high-level representation of the program structure without the necessity of containing all the details in the source code; it can be thought of as an abstract representation of the source code.\nThe specification for the abstract syntax tree to be produced by your program is below:\nmodule Decaf { prog = Program(extern* extern_list, package body) extern = ExternFunction(identifier name, method_type return_type, extern_type* typelist) decaf_type = IntType | BoolType method_type = VoidType | decaf_type extern_type = VarDef(StringType) | VarDef(decaf_type) package = Package(identifier name, field_decl* field_list, method_decl* method_list) field_decl = FieldDecl(identifier name, decaf_type type, field_size size) | AssignGlobalVar(identifier name, decaf_type type, constant value) field_size = Scalar | Array(int array_size) method_decl = Method(identifier name, method_type return_type, typed_symbol* param_list, method_block block) typed_symbol = VarDef(identifier name, decaf_type type) method_block = MethodBlock(typed_symbol* var_decl_list, statement* statement_list) block = Block(typed_symbol* var_decl_list, statement* statement_list) statement = assign | method_call | IfStmt(expr condition, block if_block, block? else_block) | WhileStmt(expr condition, block while_block) | ForStmt(assign* pre_assign_list, expr condition, assign* loop_assign_list, block for_block) | ReturnStmt(expr? return_value) | BreakStmt | ContinueStmt | block assign = AssignVar(identifier name, expr value) | AssignArrayLoc(identifier name, expr index, expr value) method_call = MethodCall(identifier name, method_arg* method_arg_list) method_arg = StringConstant(string value) | expr expr = rvalue | method_call | constant | BinaryExpr(binary_operator op, expr left_value, expr right_value) | UnaryExpr(unary_operator op, expr value) constant = NumberExpr(int value) | BoolExpr(bool value) rvalue = VariableExpr(identifier name) | ArrayLocExpr(identifier name, expr index) bool = True | False binary_operator = Plus | Minus | Mult | Div | Leftshift | Rightshift | Mod | Lt | Gt | Leq | Geq | Eq | Neq | And | Or unary_operator = UnaryMinus | Not }  The entire set of rules that describe the Decaf grammar specification is below:\nProgram = Externs package identifier \u0026quot;{\u0026quot; FieldDecls MethodDecls \u0026quot;}\u0026quot; . Externs = { ExternDefn } . ExternDefn = extern func identifier \u0026quot;(\u0026quot; [ { ExternType }+, ] \u0026quot;)\u0026quot; MethodType \u0026quot;;\u0026quot; . FieldDecls = { FieldDecl } . FieldDecl = var { identifier }+, Type \u0026quot;;\u0026quot; . FieldDecl = var { identifier }+, ArrayType \u0026quot;;\u0026quot; . FieldDecl = var identifier Type \u0026quot;=\u0026quot; Constant \u0026quot;;\u0026quot; . MethodDecls = { MethodDecl } . MethodDecl = func identifier \u0026quot;(\u0026quot; [ { identifier Type }+, ] \u0026quot;)\u0026quot; MethodType Block . Block = \u0026quot;{\u0026quot; VarDecls Statements \u0026quot;}\u0026quot; . VarDecls = { VarDecl } . VarDecl = var { identifier }+, Type \u0026quot;;\u0026quot; . Statements = { Statement } . Statement = Block . Statement = Assign \u0026quot;;\u0026quot; . Assign = Lvalue \u0026quot;=\u0026quot; Expr . Lvalue = identifier | identifier \u0026quot;[\u0026quot; Expr \u0026quot;]\u0026quot; . Statement = MethodCall \u0026quot;;\u0026quot; . MethodCall = identifier \u0026quot;(\u0026quot; [ { MethodArg }+, ] \u0026quot;)\u0026quot; . MethodArg = Expr | string_lit . Statement = if \u0026quot;(\u0026quot; Expr \u0026quot;)\u0026quot; Block [ else Block ] . Statement = while \u0026quot;(\u0026quot; Expr \u0026quot;)\u0026quot; Block . Statement = for \u0026quot;(\u0026quot; { Assign }+, \u0026quot;;\u0026quot; Expr \u0026quot;;\u0026quot; { Assign }+, \u0026quot;)\u0026quot; Block . Statement = return [ \u0026quot;(\u0026quot; [ Expr ] \u0026quot;)\u0026quot; ] \u0026quot;;\u0026quot; . Statement = break \u0026quot;;\u0026quot; . Statement = continue \u0026quot;;\u0026quot; . Expr = identifier . Expr = MethodCall . Expr = Constant . UnaryOperator = ( UnaryNot | UnaryMinus ) . UnaryNot = \u0026quot;!\u0026quot; . UnaryMinus = \u0026quot;-\u0026quot; . BinaryOperator = ( ArithmeticOperator | BooleanOperator ) . ArithmeticOperator = ( \u0026quot;+\u0026quot; | \u0026quot;-\u0026quot; | \u0026quot;*\u0026quot; | \u0026quot;/\u0026quot; | \u0026quot;\u0026lt;\u0026lt;\u0026quot; | \u0026quot;\u0026gt;\u0026gt;\u0026quot; | \u0026quot;%\u0026quot; ) . BooleanOperator = ( \u0026quot;==\u0026quot; | \u0026quot;!=\u0026quot; | \u0026quot;\u0026lt;\u0026quot; | \u0026quot;\u0026lt;=\u0026quot; | \u0026quot;\u0026gt;\u0026quot; | \u0026quot;\u0026gt;=\u0026quot; | \u0026quot;\u0026amp;\u0026amp;\u0026quot; | \u0026quot;||\u0026quot; ) . Expr = Expr BinaryOperator Expr . Expr = UnaryOperator Expr . Expr = \u0026quot;(\u0026quot; Expr \u0026quot;)\u0026quot; . Expr = identifier \u0026quot;[\u0026quot; Expr \u0026quot;]\u0026quot; . ExternType = ( string | Type ) . Type = ( int | bool ) . MethodType = ( void | Type ) . BoolConstant = ( true | false ) . ArrayType = \u0026quot;[\u0026quot; int_lit \u0026quot;]\u0026quot; Type . Constant = ( int_lit | char_lit | BoolConstant ) .  Code Generation Extend the abstract syntax tree (AST) classes to add LLVM API calls for code generation.\nOthers Control flow and Loops: Support for control flow (if statements) and loops (while and for statements) is added, including support for else blocks as well as break and continue statements.\nTo complete control flow and loops, I implemented backpatching using the symbol table to mark the entry, continue and exit points for the control flow and loops.\nShort Circuit \rShort-circuit evaluation\rfor boolean expressions is implemented.\nSemantics All the semantic checks listed in the Decaf Semantics section of the Decaf spec\rare implemented.\n","date":1618012800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1618012800,"objectID":"ffa813395b33bb9747eb3947d55008de","permalink":"/post/decaf_compiler/","publishdate":"2021-04-10T00:00:00Z","relpermalink":"/post/decaf_compiler/","section":"post","summary":"Compiler of C-like language Decaf. Github Link\rHere is an example Decaf program:\nextern func print_int(int) void; package GreatestCommonDivisor { var a int = 10; var b int = 20; func main() int { var x, y, z int; x = a; y = b; z = gcd(x, y); // print_int is part of the standard input-output library print_int(z); } // function that computes the greatest common divisor func gcd(a int, b int) int { if (b == 0) { return(a); } else { return( gcd(b, a % b) ); } } }  Usage To create the default program, go to the answer directory and type in make default.","tags":null,"title":"Decaf Compiler","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"\rGithub Link\rI implemented a memory allocator which supports allocation, deallocation, compaction and multi-threading by C.\nInstall Install the repository.\n$ make $ ./myalloc  Usage Initialization API:\nvoid initialize_allocator(int size, enum allocation_algorithm);  The allocator needs to know the total size of the contiguous memory that is assumed for the rest of the program. Any requests for allocation and deallocation requests will be served from this contiguous chunk. The memory chunk is allocated using malloc() and its content is initialized to 0 using memset. and the memory allocation algorithm to be used.\nThis memory allocator uses the following memory allocation algorithms:\n  FIRST_FIT satisfies the allocation request from the first available memory block (from left) that is at least as large as the requested size.\n  BEST_FIT satisfies the allocation request from the available memory block that at least as large as the requested size and that results in the smallest remainder fragment.\n  WORST_FIT satisfies the allocation request from the available memory block that at least as large as the requested size and that results in the largest remainder fragment.\n  All information of the contiguous memory chunk is represented in struct Myalloc:\nstruct Myalloc { enum allocation_algorithm aalgorithm; int size; void* memory; struct nodeStruct *alloc_blocks; struct nodeStruct *free_blocks; };  alloc_blocks and free_blocks are two separate singly linked lists (implemented in list.h and list.c) to manage free/allocated space. When a block gets allocated by allocate(), its metadata must be inserted to the list of allocated blocks. Similarly when a block gets freed by deallocate(), its metadata must be inserted to the list of free blocks. Note that the free list must never maintain contiguous free blocks.\nMetadata Management The size of each allocated/freed memory block is stored in header. The header should only contain a single 8-byte word that denotes the size of the actual allocation. For example, if the request asks for 16 bytes of memory, you should actually allocate 8 + 16 bytes, and use the first 8-byte to store the size of the total allocation (24 bytes) and return a pointer to the user-visible 16-byte.\nCompaction Compaction is performed by grouping the allocated memory blocks in the beginning of the memory chunk and combining the free memory at the end of the memory chunk.\n)\nThe compaction API as shown below:\nint compact_allocation(void** _before, void** _after);  The API accepts _before and _after arrays of void* pointers and insert the previous address and new address of each relocated block in _before and _after. The return integer is the total number of pointers inserted in the _before or _after array.\nMulti-threading Support The allocator uses a simple design that uses a global pthread_mutex to protect the entire allocator. That is, all the functions must first acquire the mutex before continuing to do its work, and must release the mutex before returning.\nExample The tested code is in main.c.\n$ ./myalloc Using first fit algorithm on memory size 100 p[0] = 0x7fffeee71268 ; *p[0] = 0 p[1] = 0x7fffeee71274 ; *p[1] = 1 p[2] = 0x7fffeee71280 ; *p[2] = 2 p[3] = 0x7fffeee7128c ; *p[3] = 3 p[4] = 0x7fffeee71298 ; *p[4] = 4 p[5] = 0x7fffeee712a4 ; *p[5] = 5 p[6] = 0x7fffeee712b0 ; *p[6] = 6 p[7] = 0x7fffeee712bc ; *p[7] = 7 Allocation failed Allocation failed Allocated size = 36 Allocated chunks = 8 Free size = 0 Free chunks = 0 Largest free chunk size = 0 Smallest free chunk size = 0 Freeing p[1] Freeing p[3] Freeing p[5] Freeing p[7] Freeing p[9] Allocated size = 16 Allocated chunks = 4 Free size = 20 Free chunks = 4 Largest free chunk size = 8 Smallest free chunk size = 4 available_memory 20 Allocated size = 4 Allocated chunks = 4 Free size = 44 Free chunks = 1 Largest free chunk size = 44 Smallest free chunk size = 44  ","date":1616976000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1616976000,"objectID":"b8828c15fba3d60f2853bfd877e8c8c5","permalink":"/post/memory_allocator/","publishdate":"2021-03-29T00:00:00Z","relpermalink":"/post/memory_allocator/","section":"post","summary":"Github Link\rI implemented a memory allocator which supports allocation, deallocation, compaction and multi-threading by C.\nInstall Install the repository.\n$ make $ ./myalloc  Usage Initialization API:\nvoid initialize_allocator(int size, enum allocation_algorithm);  The allocator needs to know the total size of the contiguous memory that is assumed for the rest of the program. Any requests for allocation and deallocation requests will be served from this contiguous chunk. The memory chunk is allocated using malloc() and its content is initialized to 0 using memset.","tags":null,"title":"Multi-threaded Memory Allocator by C","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"\rGithub Link\rCandyKids is a program that candy factories generate candy to a bounded buffer while kids eat candy from the bounded buffer.\nCandykids program uses the producer-consumer solution to manage access to a bounded buffer storing candy. One group of threads will model candy factories which generate candy one at a time and insert the candy into the bounded buffer. Another group of threads will model kids which eat candy one a time from the bounded buffer.\nInstall Install the repository.\n$ make\r$ ./candykids\r Usage Candykids accept three arguments:\n./candykids \u0026lt;#factories\u0026gt; \u0026lt;#kids\u0026gt; \u0026lt;#seconds\u0026gt;\rExample:\r$ ./candykids 5 2 8\r# Factories: Number of candy-factory threads to spawn.\r# Kids: Number of kid threads to spawn.\r# Seconds: Number of seconds to allow the factory thread to run for.\r Main Function  Extract arguments: Process the arguments passed on the command line. Initialize modules: Do any module initialization. Launch factory threads: Spawn the requested number of candy-factory threads. Launch kid threads: Spawn the requested number of kid threads. Wait for requested time: Call sleep(). Stop factory threads: Indicate to the factory threads that they are to finish, and then call join for each factory thread. Wait until no more candy Stop kid threads: For each kid thread, cancel the thread and then join the thread. Print statistics Cleanup any allocated memory  Stats $ ./candykids 8 3 7\rFactory 0 ships candy \u0026amp; waits 3s\rFactory 1 ships candy \u0026amp; waits 3s\rFactory 3 ships candy \u0026amp; waits 3s\rFactory 2 ships candy \u0026amp; waits 3s\rFactory 4 ships candy \u0026amp; waits 3s\rFactory 5 ships candy \u0026amp; waits 3s\rFactory 6 ships candy \u0026amp; waits 3s\rFactory 7 ships candy \u0026amp; waits 3s\rFactory 7 ships candy \u0026amp; waits 2s\rFactory 1 ships candy \u0026amp; waits 2s\rFactory 4 ships candy \u0026amp; waits 2s\rFactory 6 ships candy \u0026amp; waits 2s\rFactory 3 ships candy \u0026amp; waits 2s\rFactory 2 ships candy \u0026amp; waits 3s\rFactory 0 ships candy \u0026amp; waits 2s\rFactory 5 ships candy \u0026amp; waits 3s\rFactory 0 ships candy \u0026amp; waits 1s\rFactory 6 ships candy \u0026amp; waits 2s\rFactory 1 ships candy \u0026amp; waits 1s\rFactory 3 ships candy \u0026amp; waits 1s\rFactory 7 ships candy \u0026amp; waits 1s\rFactory 4 ships candy \u0026amp; waits 1s\rFactory 1 ships candy \u0026amp; waits 3s\rFactory 2 ships candy \u0026amp; waits 3s\rFactory 0 ships candy \u0026amp; waits 3s\rFactory 5 ships candy \u0026amp; waits 3s\rFactory 4 ships candy \u0026amp; waits 3s\rFactory 3 ships candy \u0026amp; waits 3s\rFactory 7 ships candy \u0026amp; waits 3s\rCandy-factory 6 done.\rCandy-factory 0 done.\rCandy-factory 5 done.\rCandy-factory 2 done.\rCandy-factory 1 done.\rCandy-factory 7 done.\rCandy-factory 4 done.\rCandy-factory 3 done.\rStatistics:\rFactory# #Made #Eaten Min Delay[ms] Avg Delay[ms] Max Delay[ms]\r0 4 4 0.38086 376.23212 752.57422\r1 4 4 0.36255 0.81342 1.09497\r2 3 3 0.33594 501.37191 752.58398\r3 4 4 0.34790 376.09711 752.59912\r4 4 4 0.27734 376.06390 752.61938\r5 3 3 0.23364 501.28548 752.56567\r6 3 3 0.21777 251.24194 752.60815\r7 4 4 0.13794 188.12555 750.63379\r ","date":1615075200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1615075200,"objectID":"85f4458b48060d9721f8eeb078cdfdc5","permalink":"/post/candykids/","publishdate":"2021-03-07T00:00:00Z","relpermalink":"/post/candykids/","section":"post","summary":"Github Link\rCandyKids is a program that candy factories generate candy to a bounded buffer while kids eat candy from the bounded buffer.\nCandykids program uses the producer-consumer solution to manage access to a bounded buffer storing candy. One group of threads will model candy factories which generate candy one at a time and insert the candy into the bounded buffer. Another group of threads will model kids which eat candy one a time from the bounded buffer.","tags":null,"title":"CandyKids","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"\rGithub Link\rLinux shell accepts user commands and then executes each command in a separate process. The shell provides the user a prompt at which the next command is entered.\nOne technique for implementing a shell interface is to have the parent process first read what the user enters on the command line and then create a separate child process that performs the command. Unless otherwise specified, the parent process waits for the child to exit before continuing. However, UNIX shells typically also allow the child process to run in the background - or concurrently - as well by specifying the ampersand (\u0026amp;) at the end of the command. The separate child process is created using the fork() system call and the user\u0026rsquo;s command is executed by using one of the system calls in the exec() family.\nInstall Install the repository.\n$ make\r$ ./shell\r Usage Basic Shell To implement a shell interface, the parent process first calls read_command() to reads a full command from the user and tokenizes it into separate arguments. Those tokens can be passed directly to execvp() in the child process.\nUnless otherwise specified, the parent process waits for the child to exit before continuing. However, UNIX shells typically also allow the child process to run in the background - or concurrently - as well by specifying the ampersand (\u0026amp;) at the end of the command. In such circumstance, read_command() will set the in_background parameter to true\nThe main() function first calls read_command(), which . If the user enters an \u0026ldquo;\u0026amp;\u0026rdquo; as the final argument, read_command() will set the in_background parameter to true\n Fork() a child process Child process invokes execvp() using results in token array. If in_background is false, parent waits for child to finish. Otherwise, parent loops back to read_command() again immediately.  /home/alex_wang_10/repos/Linux-Shell$ ls\rmakefile README.md shell shell.c shell.o\r/home/alex_wang_10/repos/Linux-Shell$\r /home/alex_wang_10/repos/Linux-Shell$ ls \u0026amp;\r/home/alex_wang_10/repos/Linux-Shell$ makefile README.md shell shell.c shell.o\r Internal Commands Internal commands are built-in features of the shell itself, as opposed to a separate program that is executed. The commands listed below are implemented.\n exit: Exit the shell program. pwd: Display the current working directory. cd: Change the current working directory. help: Display help information on internal commands.  /home/alex_wang_10/repos/Linux-Shell$ cd ~\r/home/alex_wang_10$ cd -\r/home/alex_wang_10/repos/Linux-Shell$ cd /home/alex_wang_10$ cd repos/Linux-Shell\r/home/alex_wang_10/repos/Linux-Shell$\r History Feature Shell allows the user access up to 10 most recently entered commands.\n Command \u0026ldquo;!n\u0026rdquo; runs command number n. Command \u0026ldquo;!!\u0026rdquo; runs the previous command.  /home/alex_wang_10/repos$ history\r23 history\r22 touch a.c\r21 echo Hello!\r20 man pthread_create\r19 ls\r18 cd repos\r17 cd\r16 cd ~\r15 cd -\r14 pwd\r/home/alex_wang_10/repos$\r alex_wang_10@DESKTOP-B47DDOK:~/repos/Linux-Shell$ ./shell\r/home/alex_wang_10/repos/Linux-Shell$ echo Hello!\rHello!\r/home/alex_wang_10/repos/Linux-Shell$ !!\recho Hello!\rHello!\r/home/alex_wang_10/repos/Linux-Shell$ ls\rmakefile README.md shell shell.c shell.o\r/home/alex_wang_10/repos/Linux-Shell$ !2\rls\rmakefile README.md shell shell.c shell.o\r Signals Change your shell program to display the help information when the user presses ctrl-c (which is the SIGINT signal).\n/home/alex_wang_10/repos/Linux-Shell$ ^C\rA simple Linux Shell, version 1.0.1-release\rThese shell commands are defined internally.\rcd [dir] Change the current working directory.\rexit Exit the shell program.\rhelp [command] Display help information on internal commands.\rpwd Display the current working directory.\r/home/alex_wang_10/repos/Linux-Shell$\r ","date":1613347200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613347200,"objectID":"a1e58c261e20d45c659f8904846649c3","permalink":"/post/linux_shell/","publishdate":"2021-02-15T00:00:00Z","relpermalink":"/post/linux_shell/","section":"post","summary":"Github Link\rLinux shell accepts user commands and then executes each command in a separate process. The shell provides the user a prompt at which the next command is entered.\nOne technique for implementing a shell interface is to have the parent process first read what the user enters on the command line and then create a separate child process that performs the command. Unless otherwise specified, the parent process waits for the child to exit before continuing.","tags":null,"title":"A customized Linux Shell by C","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"99. Recover Binary Search Tree Problem Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nExample:\nInput: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \\ 1 4 / 3  Algorithm In case of binary search trees (BST), in-order traversal gives nodes in non-decreasing order. Since that exactly two elements of BST are swapped, exactly two elements in the array of in-order traversal is swapped mistakenly.\nExample:\n[1, 5, 3, 4, 2, 6]  We compare each pair of elements.\n In the first abnormal pair of elements, [5, 3], the previous element is the first swapped element; In the last abnormal pair of elements, [4, 2], the latter element is the second swapped element.  Space Complexity This problem can have a constant space solution.\nThe process of in-order traversal does not need space and only the previous TreeNode is recorded.\nCode class Solution { public: TreeNode* first = NULL; TreeNode* second = NULL; TreeNode* pre = new TreeNode(INT_MIN); void InOrder(TreeNode* root){ if(root == NULL){ return; } InOrder(root -\u0026gt; left); if(first == NULL \u0026amp;\u0026amp; root -\u0026gt; val \u0026lt; pre -\u0026gt; val){ first = pre; } if(first != NULL \u0026amp;\u0026amp; root -\u0026gt; val \u0026lt; pre -\u0026gt; val){ second = root; } pre = root; InOrder(root -\u0026gt; right); } void recoverTree(TreeNode* root) { InOrder(root); swap(first -\u0026gt; val, second -\u0026gt; val); } };  Did you find this page helpful? Consider sharing it üôå ","date":1594166400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594166400,"objectID":"000f03e0a1114246af7c119db4011e4d","permalink":"/post/leetcode_tree/","publishdate":"2020-07-08T00:00:00Z","relpermalink":"/post/leetcode_tree/","section":"post","summary":"99. Recover Binary Search Tree Problem Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nExample:\nInput: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \\ 1 4 / 3  Algorithm In case of binary search trees (BST), in-order traversal gives nodes in non-decreasing order. Since that exactly two elements of BST are swapped, exactly two elements in the array of in-order traversal is swapped mistakenly.","tags":null,"title":"LeetCode - Tree - Hard","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"","date":1592265600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592265600,"objectID":"d33721df551303c88c71d2416df34eeb","permalink":"/post/minisearchengine/","publishdate":"2020-06-16T00:00:00Z","relpermalink":"/post/minisearchengine/","section":"post","summary":"","tags":null,"title":"Mini Search Engine","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"The color scheme \u0026lsquo;Violet\u0026rsquo; for my home page is as follows:\n# Primary\rprimary = \u0026quot;#1c304b\u0026quot;\r# Menu\r# menu_primary = \u0026quot;#283044\u0026quot;\rmenu_primary = \u0026quot;#ffffff\u0026quot;\rmenu_text = \u0026quot;#1c304b\u0026quot;\rmenu_text_active = \u0026quot;#bf3078\u0026quot;\rmenu_title = \u0026quot;#832554\u0026quot;\r# Home sections\rbackground = \u0026quot;#ffffff\u0026quot;\rhome_section_odd = \u0026quot;#ffffff\u0026quot;\r# home_section_even = \u0026quot;#f0dfad\u0026quot;\r# home_section_even = \u0026quot;#edf0da\u0026quot;\rhome_section_even = \u0026quot;#f5f9fe\u0026quot;\r ","date":1581465600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581465600,"objectID":"0db373a22b26656a15fea2f2bf8b8a9e","permalink":"/post/color_scheme/","publishdate":"2020-02-12T00:00:00Z","relpermalink":"/post/color_scheme/","section":"post","summary":"The color scheme \u0026lsquo;Violet\u0026rsquo; for my home page is as follows:\n# Primary\rprimary = \u0026quot;#1c304b\u0026quot;\r# Menu\r# menu_primary = \u0026quot;#283044\u0026quot;\rmenu_primary = \u0026quot;#ffffff\u0026quot;\rmenu_text = \u0026quot;#1c304b\u0026quot;\rmenu_text_active = \u0026quot;#bf3078\u0026quot;\rmenu_title = \u0026quot;#832554\u0026quot;\r# Home sections\rbackground = \u0026quot;#ffffff\u0026quot;\rhome_section_odd = \u0026quot;#ffffff\u0026quot;\r# home_section_even = \u0026quot;#f0dfad\u0026quot;\r# home_section_even = \u0026quot;#edf0da\u0026quot;\rhome_section_even = \u0026quot;#f5f9fe\u0026quot;\r ","tags":null,"title":"Color Scheme 'Violet' for my Home Page","type":"post"},{"authors":["Yilin(Alex) Wang"],"categories":null,"content":"The 5th problem of Leetcode, Longest Palindromic Substring, is the first problem in the set of problems about dynamic programming.\nIn the process of completing and looking through the community, I would like to share a really interesting algorithm named Manacher\u0026rsquo;s algorithm as well as the basic solution by dynamic programming.\nProblem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample:\nInput: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer.  Dynamic Programming Algorithm To improve over the brute force solution, we first observe how we can avoid unnecessary re-computation while validating palindromes.\nConsider the case \u0026ldquo;ababa\u0026rdquo;. If we already knew that \u0026ldquo;bab\u0026rdquo; is a palindrome, it is obvious that \u0026ldquo;ababa\u0026rdquo; must be a palindrome since the two left and right end letters are the same.\n$$ P\\left (i,j \\right ) = \\left (P \\left (i+1, j-1 \\right )\\ and\\ \\mathbf S_{i} == \\mathbf S_{j}\\right ) $$\nCode c++:\nclass Solution { public: string longestPalindrome(string s) { if(s.empty()) return \u0026quot;\u0026quot;; int n = s.length(); bool isPalindrome[n][n]; fill_n(\u0026amp;isPalindrome[0][0],n*n,false); int maxLength = 0; int startIndex = 0; string result; int i, j; for(j=0; j\u0026lt;n; j++){ for(i=0; i\u0026lt;=j; i++){ isPalindrome[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; (j-i\u0026lt;=2 || isPalindrome[i+1][j-1] ); if(isPalindrome[i][j] \u0026amp;\u0026amp; j-i+1 \u0026gt; maxLength){ maxLength = j-i+1; startIndex = i; } } } result = s.substr(startIndex, maxLength); return result; } };   The fill_n() function in C++ STL is used to fill some default values in a container. The fill_n() function is used to fill values upto first n positions from a starting position. It accepts an iterator begin and the number of positions n as arguments and fills the first n position starting from the position pointed by begin with the given value.  void fill_n(iterator begin, int n, type value);   In the traversal process, variable j loops in the outer layer, while variable i loops in the inner layer. The reason is as follows.\nFor example, when we want to the value of isPalindrome[2][7], we must know the value of isPalindrome[3][6] and isPalindrome[4][5], which means that we must traverse in the order of variable j.\n  Manacher\u0026rsquo;s Algorithm Algorithm Firstly, we put aside even palindromes and focus on odd palindromes.\nEvery palindrome has a center and a right boundary, and a distance between center and right boundary, which was described as the \u0026lsquo;expansion length\u0026rsquo; of a palindrome. In this algorithm, we create an array P[i] to record the expansion length of an i-centered palindrome, and let Integer c and r to present the index of center and right boundary.\nEg: ‚Äúabacabacabb‚Äù\nWhen going from left to right, when i is at index 3, the longest palindromic substring is ‚Äúabacaba‚Äù, P[3] = 3.\nNormally, we have to traverse from P[1] to P[string.length()-2], but we don‚Äôt need to manually go to each index and expand to check the expansion length every time. This is exactly where Manacher‚Äôs algorithm optimizes better than brute force, by using some insights on how palindromes work. Let‚Äôs see how the optimization is done.\nWhen i = 4, the index is inside the scope of the current longest palindrome, i.e., i \u0026lt; r. So, instead of naively expanding at i, we want to know the minimum expansion length that is certainly possible at i, so that we can expand on that minimum P[i] and see, instead of doing from start. So, we check for mirror i‚Äô.\nAs long as the palindrome at index i‚Äô does NOT expand beyond the left boundary (l) of the current longest palindrome, we can say that the minimum certainly possible expansion length at i is P[i‚Äô].\nRemember that we are only talking about the minimum possible expansion length, the actual expansion length could be more and, we‚Äôll find that out by expanding later on. In this case, P[4] = P[2] = 0. We try to expand but still, P[4] remains 0.\nNow, if the palindrome at index i‚Äô expands beyond the left boundary (l) of the current longest palindrome, we can say that the minimum certainly possible expansion length at i is r-i.\nEg: ‚Äúacacacb‚Äù\nP[3] = 2\nP[2] = 2\nP[4] = 5‚Äì4 = 1\nYou could ask but why can‚Äôt the palindrome centered at i expand after r in this case? If it did, then it would have already been covered with the current center c only. But, it didn‚Äôt. So, P[i] = r-i.\nSo, we can sum the two situations:\nif(i\u0026gt;=right) { P[i] = 0; }else{ P[i] = min(P[MirrorIndex], right-i); }  Code c++:\nclass Solution { public: string longestPalindrome(string s) { string t; int i; for(i=0; i\u0026lt;s.length(); i++){ t += \u0026quot;#\u0026quot;; t += s[i]; } t+=\u0026quot;#\u0026quot;; vector\u0026lt;int\u0026gt; P(t.length(),0); int center = 0; int right = 0; int maxLen = 0; int resultCenter = 0; for(i=1; i\u0026lt;t.length()-1; i++){ int MirrorIndex = center - (i-center); if(i\u0026gt;=right) { P[i] = 0; }else{ P[i] = min(P[MirrorIndex], right-i); } while(i-1-P[i]\u0026gt;=0 \u0026amp;\u0026amp; i+1+P[i]\u0026lt;t.length() \u0026amp;\u0026amp; t[i-1-P[i]] == t[i+1+P[i]]){ P[i]++; } if(i+P[i]\u0026gt;center){ center = i; right = i+P[i]; } if(P[i]\u0026gt;maxLen){ maxLen = P[i]; resultCenter = i; } } return s.substr((resultCenter - maxLen)/2, maxLen); } };  References and Websites \rManacher‚Äôs Algorithm Explained‚Äî Longest Palindromic Substring\rDid you find this page helpful? Consider sharing it üôå ","date":1581465600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581465600,"objectID":"c689ef4c900542a41901512921434fba","permalink":"/post/manachers-algorithm/","publishdate":"2020-02-12T00:00:00Z","relpermalink":"/post/manachers-algorithm/","section":"post","summary":"The 5th problem of Leetcode, Longest Palindromic Substring, is the first problem in the set of problems about dynamic programming.\nIn the process of completing and looking through the community, I would like to share a really interesting algorithm named Manacher\u0026rsquo;s algorithm as well as the basic solution by dynamic programming.\nProblem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.","tags":null,"title":"Manacher's Algorithm","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic \rAcademic\r| Documentation\r Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click \rPDF Export\r: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot;\rif porridge == \u0026quot;blueberry\u0026quot;:\rprint(\u0026quot;Eating...\u0026quot;)\r  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}}\r{{% fragment %}} **Two** {{% /fragment %}}\r{{% fragment %}} Three {{% /fragment %}}\r Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}}\r- Only the speaker can read these notes\r- Press `S` key to view\r{{% /speaker_note %}}\r Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view \r  Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}}\r{{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}}\r{{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}\r  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1,\r.reveal section h2,\r.reveal section h3 {\rcolor: navy;\r}\r  Questions? \rAsk\r\rDocumentation\r","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"}]