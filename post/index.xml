<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | Yilin&#39;s Studio</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© 2024 Yilin Wang</copyright><lastBuildDate>Mon, 21 Nov 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:square]</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>Reading Source Code of Malloc in the GNU C Library</title>
      <link>/post/malloc/</link>
      <pubDate>Mon, 21 Nov 2022 00:00:00 +0000</pubDate>
      <guid>/post/malloc/</guid>
      <description>&lt;h3 id=&#34;dynamically-memory-allocation-algorithm&#34;&gt;Dynamically Memory Allocation Algorithm&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For large (&amp;gt;= 512 bytes) requests, it is a pure best-fit allocator, with ties normally decided via FIFO (i.e. least recently used).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For small (&amp;lt;= 64 bytes by default) requests, it is a caching allocator, that maintains pools of quickly recycled chunks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In between, and for combinations of large and small requests, it does the best it can trying to meet both goals at once.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For very large requests (&amp;gt;= 128KB by default), it relies on system memory mapping facilities, if supported.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vital-statistics&#34;&gt;Vital Statistics&lt;/h3&gt;
&lt;h4 id=&#34;size-of-ptr-and-size_t&#34;&gt;size of ptr and size_t&lt;/h4&gt;
&lt;p&gt;4 bytes (32-bit program) or 8 bytes (64-bit program)&lt;/p&gt;
&lt;h4 id=&#34;memory-alignment&#34;&gt;Memory Alignment&lt;/h4&gt;
&lt;p&gt;2 * sizeof(size_t)&lt;/p&gt;
&lt;p&gt;i.e. 8 or 16 bytes&lt;/p&gt;
&lt;h4 id=&#34;minimum-overhead&#34;&gt;Minimum Overhead&lt;/h4&gt;
&lt;p&gt;4 or 8 bytes per allocated chunk&lt;/p&gt;
&lt;p&gt;Each malloced chunk has a hidden word of overhead holding size and status information.&lt;/p&gt;
&lt;h3 id=&#34;chunk&#34;&gt;Chunk&lt;/h3&gt;
&lt;p&gt;An allocated chunk looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    chunk-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Free chunks are stored in circular doubly-linked lists, and look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    chunk-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:&#39; |             Size of chunk, in bytes                     |A|0|P|
      mem-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-&amp;gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:&#39; |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;bin&#34;&gt;Bin&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;An array of bin headers for free chunks. Each bin is doubly linked.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Chunks in bins are kept in size order, with ties going to the approximately least recently used chunk.&lt;/p&gt;
&lt;h3 id=&#34;fastbin&#34;&gt;Fastbin&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;An array of lists holding recently freed small chunks.&lt;/strong&gt;  Fastbins are not doubly linked.  It is faster to single-link them, and since chunks are never removed from the middles of these lists, double linking is not necessary. Also, unlike regular bins, they are not even processed in FIFO order (they use faster LIFO) since ordering doesn&amp;rsquo;t much matter in the transient contexts in which fastbins are normally used.&lt;/p&gt;
&lt;p&gt;Chunks in fastbins keep their inuse bit set, so they cannot be consolidated with other free chunks. malloc_consolidate releases all chunks in fastbins and consolidates them with other free chunks.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mini Search Engine</title>
      <link>/post/minisearchengine/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      <guid>/post/minisearchengine/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;1.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;2.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;3.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;4.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;5.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;6.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;7.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;8.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;9.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;10.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;11.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;12.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;13.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;14.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;15.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;16.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;17.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;18.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;19.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;20.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;21.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;22.bmp&#34; alt=&#34;img&#34;&gt;
&lt;img src=&#34;23.bmp&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Decaf Compiler</title>
      <link>/post/decaf_compiler/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      <guid>/post/decaf_compiler/</guid>
      <description>&lt;p&gt;Compiler of C-like language Decaf.  
&lt;a href=&#34;https://github.com/Aiixalex/Decaf-Compiler&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;&lt;strong&gt;Github Link&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Here is an example Decaf program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern func print_int(int) void;

package GreatestCommonDivisor {
    var a int = 10;
    var b int = 20;

    func main() int {
        var x, y, z int;
        x = a;
        y = b;
        z = gcd(x, y);

        // print_int is part of the standard input-output library
        print_int(z);
    }

    // function that computes the greatest common divisor
    func gcd(a int, b int) int {
        if (b == 0) { return(a); }
        else { return( gcd(b, a % b) ); }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;p&gt;To create the default program, go to the answer directory and type in &lt;code&gt;make default&lt;/code&gt;. To run the default program against the testcases, run the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python zipout.py -r default
$ python check.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output files are saved to the &lt;code&gt;output&lt;/code&gt; directory while all the intermediate LLVM files created for each input Decaf program are saved to the &lt;code&gt;llvm&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;Directory &lt;code&gt;dev_llvm&lt;/code&gt; contains sample output LLVM assembly for each Decaf program in &lt;code&gt;testcases/dev&lt;/code&gt;. You can check that your output LLVM assembly is roughly doing the right thing by comparing your output to this sample output.&lt;/p&gt;
&lt;p&gt;Here are several shell scripts that helps streamline parts of the process.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attempt&lt;/th&gt;
&lt;th&gt;description&lt;/th&gt;
&lt;th&gt;args&lt;/th&gt;
&lt;th&gt;output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;build.sh&lt;/td&gt;
&lt;td&gt;Builds the project and runs against testcases in &lt;code&gt;testcases&lt;/code&gt; directory.&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;evaluate.sh&lt;/td&gt;
&lt;td&gt;Compares all the project&amp;rsquo;s output files in &lt;code&gt;output&lt;/code&gt; directory against the given references in &lt;code&gt;reference&lt;/code&gt; directory to find any failing tests, and where the difference occurs.&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;None if all outputs are correct, file name and position of difference if failure occurred.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;result.sh&lt;/td&gt;
&lt;td&gt;Provides outputs for user to compare their output against the reference output, as well as the used test case.&lt;/td&gt;
&lt;td&gt;file names without extension&lt;/td&gt;
&lt;td&gt;Provides the project&amp;rsquo;s original test case, reference output, and the project&amp;rsquo;s output.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Several use-case examples of the scripts are in &lt;code&gt;README.md&lt;/code&gt; in directory &lt;code&gt;scripts&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;program&#34;&gt;Program&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;makefile&lt;/code&gt;: contains the necessary recipes for building LLVM assembly code, C++ code using LLVM API calls and Lex/Yacc programs that use the LLVM API.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decaf-stdlib.c&lt;/code&gt;: the Decaf standard library. Contains the extern functions used commonly in Decaf programs.&lt;/li&gt;
&lt;li&gt;Solution files:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default-defs.h&lt;/code&gt;: the common header file among all the default files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decafcomp.cc&lt;/code&gt;: classes for LLVM code generation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decafcomp.lex&lt;/code&gt;: the lexer for Decaf&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decafcomp.y&lt;/code&gt;: the yacc program for a small fragment of Decaf which uses &lt;code&gt;decafcomp.cc&lt;/code&gt; for LLVM code generation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;llvm-run&lt;/code&gt;: the Python program used by &lt;code&gt;check.py&lt;/code&gt; in order to run a Decaf program using the following steps. Each step assumes some file names but can be changed using command line options so run &lt;code&gt;llvm-run -h&lt;/code&gt; to see the options and also read the source code of &lt;code&gt;llvm-run&lt;/code&gt; to understand what it is doing.  Stages are:
&lt;ul&gt;
&lt;li&gt;llvm: source code to LLVM code generation&lt;/li&gt;
&lt;li&gt;bc: assembly to LLVM bitcode&lt;/li&gt;
&lt;li&gt;s: bitcode to native code&lt;/li&gt;
&lt;li&gt;exec: linking to make native executable&lt;/li&gt;
&lt;li&gt;run: running the final executable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;implemented-grammar&#34;&gt;Implemented Grammar&lt;/h2&gt;
&lt;h3 id=&#34;lexer&#34;&gt;Lexer&lt;/h3&gt;
&lt;p&gt;The lexical analyzer produces a stream of tokens for a given Decaf program. The input is taken from &lt;code&gt;stdin&lt;/code&gt; (standard input) and the output token stream is sent to &lt;code&gt;stdout&lt;/code&gt; (standard output). Errors are issued on the &lt;code&gt;stderr&lt;/code&gt; (standard error) stream.&lt;/p&gt;
&lt;p&gt;The lexical analyzer produces the following token stream:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T_AND            &amp;amp;&amp;amp;
T_ASSIGN         =
T_BOOLTYPE       bool
T_BREAK          break
T_CHARCONSTANT   char_lit (see section on Character literals)
T_COMMA          ,
T_COMMENT        comment
T_CONTINUE       continue
T_DIV            /
T_DOT            .
T_ELSE           else
T_EQ             ==
T_EXTERN         extern
T_FALSE          false
T_FOR            for
T_FUNC           func
T_GEQ            &amp;gt;=
T_GT             &amp;gt;
T_ID             identifier (see section on Identifiers)
T_IF             if
T_INTCONSTANT    int_lit (see section on Integer literals)
T_INTTYPE        int
T_LCB            {
T_LEFTSHIFT      &amp;lt;&amp;lt;
T_LEQ            &amp;lt;=
T_LPAREN         (
T_LSB            [
T_LT             &amp;lt;
T_MINUS          -
T_MOD            %
T_MULT           *
T_NEQ            !=
T_NOT            !
T_NULL           null
T_OR             ||
T_PACKAGE        package
T_PLUS           +
T_RCB            }
T_RETURN         return
T_RIGHTSHIFT     &amp;gt;&amp;gt;
T_RPAREN         )
T_RSB            ]
T_SEMICOLON      ;
T_STRINGCONSTANT string_lit (see section on String literals)
T_STRINGTYPE     string
T_TRUE           true
T_VAR            var
T_VOID           void
T_WHILE          while
T_WHITESPACE     whitespace (see section on Whitespace)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;parser&#34;&gt;Parser&lt;/h3&gt;
&lt;p&gt;The parser of the compiler produces an abstract syntax tree for valid Decaf programs.&lt;/p&gt;
&lt;p&gt;An abstract syntax tree (AST) is a high-level representation of the program structure without the necessity of containing all the details in the source code; it can be thought of as an abstract representation of the source code.&lt;/p&gt;
&lt;p&gt;The specification for the abstract syntax tree to be produced by your program is below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-asdl&#34;&gt;module Decaf
{
    prog = Program(extern* extern_list, package body)

    extern = ExternFunction(identifier name, method_type return_type, extern_type* typelist)

    decaf_type = IntType | BoolType

    method_type = VoidType | decaf_type

    extern_type  = VarDef(StringType) | VarDef(decaf_type)

    package = Package(identifier name, field_decl* field_list, method_decl* method_list)

    field_decl = FieldDecl(identifier name, decaf_type type, field_size size)
        | AssignGlobalVar(identifier name, decaf_type type, constant value)

    field_size = Scalar | Array(int array_size)

    method_decl = Method(identifier name, method_type return_type, typed_symbol* param_list, method_block block)

    typed_symbol = VarDef(identifier name, decaf_type type)

    method_block = MethodBlock(typed_symbol* var_decl_list, statement* statement_list)

    block = Block(typed_symbol* var_decl_list, statement* statement_list)

    statement = assign
        | method_call
        | IfStmt(expr condition, block if_block, block? else_block)
        | WhileStmt(expr condition, block while_block)
        | ForStmt(assign* pre_assign_list, expr condition, assign* loop_assign_list, block for_block)
        | ReturnStmt(expr? return_value)
        | BreakStmt
        | ContinueStmt
        | block

    assign = AssignVar(identifier name, expr value)
        | AssignArrayLoc(identifier name, expr index, expr value)

    method_call = MethodCall(identifier name, method_arg* method_arg_list)

    method_arg = StringConstant(string value)
        | expr

    expr = rvalue
        | method_call
        | constant
        | BinaryExpr(binary_operator op, expr left_value, expr right_value)
        | UnaryExpr(unary_operator op, expr value)

    constant = NumberExpr(int value)
        | BoolExpr(bool value)

    rvalue = VariableExpr(identifier name)
        | ArrayLocExpr(identifier name, expr index)

    bool = True | False

    binary_operator = Plus | Minus | Mult | Div | Leftshift | Rightshift | Mod | Lt | Gt | Leq | Geq | Eq | Neq | And | Or

    unary_operator = UnaryMinus | Not
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The entire set of rules that describe the &lt;code&gt;Decaf&lt;/code&gt; grammar specification is below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Program = Externs package identifier &amp;quot;{&amp;quot; FieldDecls MethodDecls &amp;quot;}&amp;quot; .
Externs    = { ExternDefn } .
ExternDefn = extern func identifier &amp;quot;(&amp;quot; [ { ExternType }+, ] &amp;quot;)&amp;quot; MethodType &amp;quot;;&amp;quot; .
FieldDecls = { FieldDecl } .
FieldDecl  = var { identifier }+, Type &amp;quot;;&amp;quot; .
FieldDecl  = var { identifier }+, ArrayType &amp;quot;;&amp;quot; .
FieldDecl  = var identifier Type &amp;quot;=&amp;quot; Constant &amp;quot;;&amp;quot; .
MethodDecls = { MethodDecl } .
MethodDecl  = func identifier &amp;quot;(&amp;quot; [ { identifier Type }+, ] &amp;quot;)&amp;quot; MethodType Block .
Block = &amp;quot;{&amp;quot; VarDecls Statements &amp;quot;}&amp;quot; .
VarDecls = { VarDecl } .
VarDecl  = var { identifier }+, Type &amp;quot;;&amp;quot; .
Statements = { Statement } .
Statement = Block .
Statement = Assign &amp;quot;;&amp;quot; .
Assign    = Lvalue &amp;quot;=&amp;quot; Expr .
Lvalue    = identifier | identifier &amp;quot;[&amp;quot; Expr &amp;quot;]&amp;quot; .
Statement  = MethodCall &amp;quot;;&amp;quot; .
MethodCall = identifier &amp;quot;(&amp;quot; [ { MethodArg }+, ] &amp;quot;)&amp;quot; .
MethodArg  = Expr | string_lit .
Statement = if &amp;quot;(&amp;quot; Expr &amp;quot;)&amp;quot; Block [ else Block ] .
Statement =  while &amp;quot;(&amp;quot; Expr &amp;quot;)&amp;quot; Block .
Statement = for &amp;quot;(&amp;quot; { Assign }+, &amp;quot;;&amp;quot; Expr &amp;quot;;&amp;quot; { Assign }+, &amp;quot;)&amp;quot; Block .
Statement = return [ &amp;quot;(&amp;quot; [ Expr ] &amp;quot;)&amp;quot; ] &amp;quot;;&amp;quot; .
Statement = break &amp;quot;;&amp;quot; .
Statement = continue &amp;quot;;&amp;quot; .
Expr = identifier .
Expr = MethodCall .
Expr = Constant .
UnaryOperator = ( UnaryNot | UnaryMinus ) .
UnaryNot = &amp;quot;!&amp;quot; .
UnaryMinus = &amp;quot;-&amp;quot; .
BinaryOperator = ( ArithmeticOperator | BooleanOperator ) .
ArithmeticOperator = ( &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot;*&amp;quot; | &amp;quot;/&amp;quot; | &amp;quot;&amp;lt;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;gt;&amp;quot; | &amp;quot;%&amp;quot; ) .
BooleanOperator = ( &amp;quot;==&amp;quot; | &amp;quot;!=&amp;quot; | &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;lt;=&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;&amp;gt;=&amp;quot; | &amp;quot;&amp;amp;&amp;amp;&amp;quot; | &amp;quot;||&amp;quot; ) .
Expr = Expr BinaryOperator Expr .
Expr = UnaryOperator Expr .
Expr = &amp;quot;(&amp;quot; Expr &amp;quot;)&amp;quot; .
Expr = identifier &amp;quot;[&amp;quot; Expr &amp;quot;]&amp;quot; .
ExternType = ( string | Type ) .
Type = ( int | bool ) .
MethodType = ( void | Type ) .
BoolConstant = ( true | false ) .
ArrayType = &amp;quot;[&amp;quot; int_lit &amp;quot;]&amp;quot; Type .
Constant = ( int_lit | char_lit | BoolConstant ) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;code-generation&#34;&gt;Code Generation&lt;/h3&gt;
&lt;p&gt;Extend the abstract syntax tree (AST) classes to add LLVM API calls for code generation.&lt;/p&gt;
&lt;h3 id=&#34;others&#34;&gt;Others&lt;/h3&gt;
&lt;h4 id=&#34;control-flow-and-loops&#34;&gt;Control flow and Loops:&lt;/h4&gt;
&lt;p&gt;Support for control flow (&lt;code&gt;if&lt;/code&gt; statements) and loops (&lt;code&gt;while&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; statements) is added, including support for &lt;code&gt;else&lt;/code&gt; blocks as well as &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; statements.&lt;/p&gt;
&lt;p&gt;To complete control flow and loops, I implemented backpatching using the symbol table to mark the entry, continue and exit points for the control flow and loops.&lt;/p&gt;
&lt;h4 id=&#34;short-circuit&#34;&gt;Short Circuit&lt;/h4&gt;
&lt;p&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Short-circuit_evaluation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Short-circuit evaluation&lt;/a&gt;
 for boolean expressions is implemented.&lt;/p&gt;
&lt;h4 id=&#34;semantics&#34;&gt;Semantics&lt;/h4&gt;
&lt;p&gt;All the semantic checks listed in the Decaf Semantics section of the 
&lt;a href=&#34;http://anoopsarkar.github.io/compilers-class/decafspec.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Decaf spec&lt;/strong&gt;&lt;/a&gt;
 are implemented.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multi-threaded Memory Allocator by C</title>
      <link>/post/memory_allocator/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/memory_allocator/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://github.com/Aiixalex/Multi-Threaded-Memory-Allocator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;&lt;strong&gt;Github Link&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;I implemented a memory allocator which supports allocation, deallocation, compaction and multi-threading by C.&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;Install the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make
$ ./myalloc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;h3 id=&#34;initialization&#34;&gt;Initialization&lt;/h3&gt;
&lt;p&gt;API:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize_allocator(int size, enum allocation_algorithm);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The allocator needs to know the total size of the contiguous memory that is assumed for the rest of the program. Any requests for allocation and deallocation requests will be served from this contiguous chunk. The memory chunk is allocated using &lt;code&gt;malloc()&lt;/code&gt; and its content is initialized to 0 using &lt;code&gt;memset&lt;/code&gt;. and the memory allocation algorithm to be used.&lt;/p&gt;
&lt;p&gt;This memory allocator uses the following memory allocation algorithms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FIRST_FIT satisfies the allocation request from the first available memory block (from left) that is at least as large as the requested size.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BEST_FIT satisfies the allocation request from the available memory block that at least as large as the requested size and that results in the smallest remainder fragment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WORST_FIT satisfies the allocation request from the available memory block that at least as large as the requested size and that results in the largest remainder fragment.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All information of the contiguous memory chunk is represented in &lt;code&gt;struct Myalloc&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct Myalloc {
    enum allocation_algorithm aalgorithm;
    int size;
    void* memory;
    struct nodeStruct *alloc_blocks;
    struct nodeStruct *free_blocks;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;alloc_blocks&lt;/code&gt; and &lt;code&gt;free_blocks&lt;/code&gt; are two separate singly linked lists (implemented in &lt;code&gt;list.h&lt;/code&gt; and &lt;code&gt;list.c&lt;/code&gt;) to manage free/allocated space. When a block gets allocated by &lt;code&gt;allocate()&lt;/code&gt;, its metadata must be inserted to the list of allocated blocks. Similarly when a block gets freed by &lt;code&gt;deallocate()&lt;/code&gt;, its metadata must be inserted to the list of free blocks. Note that the free list must never maintain contiguous free blocks.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mystudio-1304603642.cos.ap-nanjing.myqcloud.com/img/1.bmp&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;metadata-management&#34;&gt;Metadata Management&lt;/h3&gt;
&lt;p&gt;The size of each allocated/freed memory block is stored in header. The header should only contain a single 8-byte word that denotes the size of the actual allocation. For example, if the request asks for 16 bytes of memory, you should actually allocate 8 + 16 bytes, and use the first 8-byte to store the size of the total allocation (24 bytes) and return a pointer to the user-visible 16-byte.&lt;/p&gt;
&lt;h3 id=&#34;compaction&#34;&gt;Compaction&lt;/h3&gt;
&lt;p&gt;Compaction is performed by grouping the allocated memory blocks in the beginning of the memory chunk and combining the free memory at the end of the memory chunk.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mystudio-1304603642.cos.ap-nanjing.myqcloud.com/img/2.bmp&#34; alt=&#34;2&#34;&gt;)&lt;/p&gt;
&lt;p&gt;The compaction API as shown below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int compact_allocation(void** _before, void** _after);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The API accepts &lt;code&gt;_before&lt;/code&gt; and &lt;code&gt;_after&lt;/code&gt; arrays of &lt;code&gt;void*&lt;/code&gt; pointers and insert the previous address and new address of each relocated block in &lt;code&gt;_before&lt;/code&gt; and &lt;code&gt;_after&lt;/code&gt;. The return integer is the total number of pointers inserted in the &lt;code&gt;_before&lt;/code&gt; or &lt;code&gt;_after&lt;/code&gt; array.&lt;/p&gt;
&lt;h3 id=&#34;multi-threading-support&#34;&gt;Multi-threading Support&lt;/h3&gt;
&lt;p&gt;The allocator uses a simple design that uses a global &lt;code&gt;pthread_mutex&lt;/code&gt; to protect the entire allocator. That is, all the functions must first acquire the mutex before continuing to do its work, and must release the mutex before returning.&lt;/p&gt;
&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;
&lt;p&gt;The tested code is in &lt;code&gt;main.c&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./myalloc
Using first fit algorithm on memory size 100
p[0] = 0x7fffeee71268 ; *p[0] = 0
p[1] = 0x7fffeee71274 ; *p[1] = 1
p[2] = 0x7fffeee71280 ; *p[2] = 2
p[3] = 0x7fffeee7128c ; *p[3] = 3
p[4] = 0x7fffeee71298 ; *p[4] = 4
p[5] = 0x7fffeee712a4 ; *p[5] = 5
p[6] = 0x7fffeee712b0 ; *p[6] = 6
p[7] = 0x7fffeee712bc ; *p[7] = 7
Allocation failed
Allocation failed
Allocated size = 36
Allocated chunks = 8
Free size = 0
Free chunks = 0
Largest free chunk size = 0
Smallest free chunk size = 0
Freeing p[1]
Freeing p[3]
Freeing p[5]
Freeing p[7]
Freeing p[9]
Allocated size = 16
Allocated chunks = 4
Free size = 20
Free chunks = 4
Largest free chunk size = 8
Smallest free chunk size = 4
available_memory 20
Allocated size = 4
Allocated chunks = 4
Free size = 44
Free chunks = 1
Largest free chunk size = 44
Smallest free chunk size = 44
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CandyKids</title>
      <link>/post/candykids/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/candykids/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://github.com/Aiixalex/CandyKids&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;&lt;strong&gt;Github Link&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;CandyKids is a program that candy factories generate candy to a bounded buffer while kids eat candy from the bounded buffer.&lt;/p&gt;
&lt;p&gt;Candykids program uses the producer-consumer solution to manage access to a bounded buffer storing candy. One group of threads will model candy factories which generate candy one at a time and insert the candy into the bounded buffer. Another group of threads will model kids which eat candy one a time from the bounded buffer.&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;Install the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make
$ ./candykids
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;p&gt;Candykids accept three arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./candykids &amp;lt;#factories&amp;gt; &amp;lt;#kids&amp;gt; &amp;lt;#seconds&amp;gt;

Example:
$ ./candykids 5 2 8
# Factories: Number of candy-factory threads to spawn.
# Kids: Number of kid threads to spawn.
# Seconds: Number of seconds to allow the factory thread to run for.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;main-function&#34;&gt;Main Function&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Extract arguments: Process the arguments passed on the command line.&lt;/li&gt;
&lt;li&gt;Initialize modules: Do any module initialization.&lt;/li&gt;
&lt;li&gt;Launch factory threads: Spawn the requested number of candy-factory threads.&lt;/li&gt;
&lt;li&gt;Launch kid threads: Spawn the requested number of kid threads.&lt;/li&gt;
&lt;li&gt;Wait for requested time: Call sleep().&lt;/li&gt;
&lt;li&gt;Stop factory threads: Indicate to the factory threads that they are to finish, and then call join for each factory thread.&lt;/li&gt;
&lt;li&gt;Wait until no more candy&lt;/li&gt;
&lt;li&gt;Stop kid threads: For each kid thread, cancel the thread and then join the thread.&lt;/li&gt;
&lt;li&gt;Print statistics&lt;/li&gt;
&lt;li&gt;Cleanup any allocated memory&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;stats&#34;&gt;Stats&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./candykids 8 3 7
Factory 0 ships candy &amp;amp; waits 3s
Factory 1 ships candy &amp;amp; waits 3s
Factory 3 ships candy &amp;amp; waits 3s
Factory 2 ships candy &amp;amp; waits 3s
Factory 4 ships candy &amp;amp; waits 3s
Factory 5 ships candy &amp;amp; waits 3s
Factory 6 ships candy &amp;amp; waits 3s
Factory 7 ships candy &amp;amp; waits 3s
Factory 7 ships candy &amp;amp; waits 2s
Factory 1 ships candy &amp;amp; waits 2s
Factory 4 ships candy &amp;amp; waits 2s
Factory 6 ships candy &amp;amp; waits 2s
Factory 3 ships candy &amp;amp; waits 2s
Factory 2 ships candy &amp;amp; waits 3s
Factory 0 ships candy &amp;amp; waits 2s
Factory 5 ships candy &amp;amp; waits 3s
Factory 0 ships candy &amp;amp; waits 1s
Factory 6 ships candy &amp;amp; waits 2s
Factory 1 ships candy &amp;amp; waits 1s
Factory 3 ships candy &amp;amp; waits 1s
Factory 7 ships candy &amp;amp; waits 1s
Factory 4 ships candy &amp;amp; waits 1s
Factory 1 ships candy &amp;amp; waits 3s
Factory 2 ships candy &amp;amp; waits 3s
Factory 0 ships candy &amp;amp; waits 3s
Factory 5 ships candy &amp;amp; waits 3s
Factory 4 ships candy &amp;amp; waits 3s
Factory 3 ships candy &amp;amp; waits 3s
Factory 7 ships candy &amp;amp; waits 3s
Candy-factory 6 done.
Candy-factory 0 done.
Candy-factory 5 done.
Candy-factory 2 done.
Candy-factory 1 done.
Candy-factory 7 done.
Candy-factory 4 done.
Candy-factory 3 done.
Statistics:
Factory#   #Made  #Eaten  Min Delay[ms]  Avg Delay[ms]  Max Delay[ms]
       0       4       4        0.38086      376.23212      752.57422
       1       4       4        0.36255        0.81342        1.09497
       2       3       3        0.33594      501.37191      752.58398
       3       4       4        0.34790      376.09711      752.59912
       4       4       4        0.27734      376.06390      752.61938
       5       3       3        0.23364      501.28548      752.56567
       6       3       3        0.21777      251.24194      752.60815
       7       4       4        0.13794      188.12555      750.63379
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>A customized Linux Shell by C</title>
      <link>/post/linux_shell/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      <guid>/post/linux_shell/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://github.com/Aiixalex/Linux-Shell&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;&lt;strong&gt;Github Link&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;Linux shell accepts user commands and then executes each command in a separate process. The shell provides the user a prompt at which the next command is entered.&lt;/p&gt;
&lt;p&gt;One technique for implementing a shell interface is to have the parent process first read what the user enters on the command line and then create a separate child process that performs the command. Unless otherwise specified, the parent process waits for the child to exit before continuing. However, UNIX shells typically also allow the child process to run in the background - or concurrently - as well by specifying the ampersand (&amp;amp;) at the end of the command. The separate child process is created using the &lt;code&gt;fork()&lt;/code&gt; system call and the user&amp;rsquo;s command is executed by using one of the system calls in the &lt;code&gt;exec()&lt;/code&gt; family.&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;Install the repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make
$ ./shell
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;h3 id=&#34;basic-shell&#34;&gt;Basic Shell&lt;/h3&gt;
&lt;p&gt;To implement a shell interface, the parent process first calls &lt;code&gt;read_command()&lt;/code&gt; to reads a full command from the user and tokenizes it into separate arguments. Those tokens can be passed directly to &lt;code&gt;execvp()&lt;/code&gt; in the child process.&lt;/p&gt;
&lt;p&gt;Unless otherwise specified, the parent process waits for the child to exit before continuing. However, UNIX shells typically also allow the child process to run in the background - or concurrently - as well by specifying the ampersand (&amp;amp;) at the end of the command. In such circumstance, &lt;code&gt;read_command()&lt;/code&gt; will set the &lt;code&gt;in_background&lt;/code&gt; parameter to true&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;main()&lt;/code&gt; function first calls &lt;code&gt;read_command()&lt;/code&gt;, which .  If the user enters an &amp;ldquo;&amp;amp;&amp;rdquo; as the final argument, &lt;code&gt;read_command()&lt;/code&gt; will set the &lt;code&gt;in_background&lt;/code&gt; parameter to true&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Fork()&lt;/code&gt; a child process&lt;/li&gt;
&lt;li&gt;Child process invokes &lt;code&gt;execvp()&lt;/code&gt; using results in token array.&lt;/li&gt;
&lt;li&gt;If in_background is false, parent waits for child to finish. Otherwise, parent loops back to &lt;code&gt;read_command()&lt;/code&gt; again immediately.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/home/alex_wang_10/repos/Linux-Shell$ ls
makefile  README.md  shell  shell.c  shell.o
/home/alex_wang_10/repos/Linux-Shell$
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/home/alex_wang_10/repos/Linux-Shell$ ls &amp;amp;
/home/alex_wang_10/repos/Linux-Shell$ makefile  README.md  shell  shell.c  shell.o
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;internal-commands&#34;&gt;Internal Commands&lt;/h3&gt;
&lt;p&gt;Internal commands are built-in features of the shell itself, as opposed to a separate program that is executed. The commands listed below are implemented.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exit&lt;/code&gt;: Exit the shell program.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pwd&lt;/code&gt;: Display the current working directory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt;: Change the current working directory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help&lt;/code&gt;: Display help information on internal commands.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/home/alex_wang_10/repos/Linux-Shell$ cd ~
/home/alex_wang_10$ cd -
/home/alex_wang_10/repos/Linux-Shell$ cd 
/home/alex_wang_10$ cd repos/Linux-Shell
/home/alex_wang_10/repos/Linux-Shell$
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;history-feature&#34;&gt;History Feature&lt;/h3&gt;
&lt;p&gt;Shell allows the user access up to 10 most recently entered commands.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command &amp;ldquo;!n&amp;rdquo; runs command number n.&lt;/li&gt;
&lt;li&gt;Command &amp;ldquo;!!&amp;rdquo; runs the previous command.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/home/alex_wang_10/repos$ history
23        history
22        touch a.c
21        echo Hello!
20        man pthread_create
19        ls
18        cd repos
17        cd
16        cd ~
15        cd -
14        pwd
/home/alex_wang_10/repos$
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;alex_wang_10@DESKTOP-B47DDOK:~/repos/Linux-Shell$ ./shell
/home/alex_wang_10/repos/Linux-Shell$ echo Hello!
Hello!
/home/alex_wang_10/repos/Linux-Shell$ !!
echo Hello!
Hello!
/home/alex_wang_10/repos/Linux-Shell$ ls
makefile  README.md  shell  shell.c  shell.o
/home/alex_wang_10/repos/Linux-Shell$ !2
ls
makefile  README.md  shell  shell.c  shell.o
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;signals&#34;&gt;Signals&lt;/h3&gt;
&lt;p&gt;Change your shell program to display the help information when the user presses ctrl-c (which is the SIGINT signal).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/home/alex_wang_10/repos/Linux-Shell$ ^C
A simple Linux Shell, version 1.0.1-release
These shell commands are defined internally.
cd [dir]         Change the current working directory.
exit             Exit the shell program.
help [command]   Display help information on internal commands.
pwd              Display the current working directory.
/home/alex_wang_10/repos/Linux-Shell$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Color Scheme &#39;Violet&#39; for my Home Page</title>
      <link>/post/color_scheme/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      <guid>/post/color_scheme/</guid>
      <description>&lt;p&gt;The color scheme &lt;strong&gt;&amp;lsquo;Violet&amp;rsquo;&lt;/strong&gt; for my home page is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# Primary
primary = &amp;quot;#1c304b&amp;quot;

# Menu
# menu_primary = &amp;quot;#283044&amp;quot;
menu_primary = &amp;quot;#ffffff&amp;quot;
menu_text = &amp;quot;#1c304b&amp;quot;
menu_text_active = &amp;quot;#bf3078&amp;quot;
menu_title = &amp;quot;#832554&amp;quot;

# Home sections
background = &amp;quot;#ffffff&amp;quot;
home_section_odd = &amp;quot;#ffffff&amp;quot;
# home_section_even = &amp;quot;#f0dfad&amp;quot;
# home_section_even = &amp;quot;#edf0da&amp;quot;
home_section_even = &amp;quot;#f5f9fe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Manacher&#39;s Algorithm</title>
      <link>/post/manachers-algorithm/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      <guid>/post/manachers-algorithm/</guid>
      <description>&lt;p&gt;The 5th problem of Leetcode, &lt;strong&gt;Longest Palindromic Substring&lt;/strong&gt;, is the first problem in the set of problems about dynamic programming.&lt;/p&gt;
&lt;p&gt;In the process of completing and looking through the community, I would like to share a really interesting algorithm named &lt;strong&gt;Manacher&amp;rsquo;s algorithm&lt;/strong&gt; as well as the basic solution by dynamic programming.&lt;/p&gt;
&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a string &lt;strong&gt;s&lt;/strong&gt;, find the longest palindromic substring in &lt;strong&gt;s&lt;/strong&gt;. You may assume that the maximum length of &lt;strong&gt;s&lt;/strong&gt; is 1000.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;Input: &amp;quot;babad&amp;quot;
Output: &amp;quot;bab&amp;quot;
Note: &amp;quot;aba&amp;quot; is also a valid answer.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dynamic-programming&#34;&gt;Dynamic Programming&lt;/h2&gt;
&lt;h3 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h3&gt;
&lt;p&gt;To improve over the brute force solution, we first observe how we can avoid unnecessary re-computation while validating palindromes.&lt;/p&gt;
&lt;p&gt;Consider the case &amp;ldquo;ababa&amp;rdquo;. If we already knew that &amp;ldquo;bab&amp;rdquo; is a palindrome, it is obvious that &amp;ldquo;ababa&amp;rdquo; must be a palindrome since the two left and right end letters are the same.&lt;/p&gt;
&lt;p&gt;$$
P\left (i,j \right ) = \left (P \left (i+1, j-1 \right )\ and\ \mathbf S_{i} == \mathbf S_{j}\right )
$$&lt;/p&gt;
&lt;h3 id=&#34;code&#34;&gt;Code&lt;/h3&gt;
&lt;p&gt;c++:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string longestPalindrome(string s) {
        if(s.empty()) return &amp;quot;&amp;quot;;
        int n = s.length();
        bool isPalindrome[n][n];
        fill_n(&amp;amp;isPalindrome[0][0],n*n,false);
        int maxLength = 0;
        int startIndex = 0;
        string result;
                
        int i, j;
        
        for(j=0; j&amp;lt;n; j++){
            for(i=0; i&amp;lt;=j; i++){
                isPalindrome[i][j] = (s[i] == s[j]) &amp;amp;&amp;amp; 
                    (j-i&amp;lt;=2 || isPalindrome[i+1][j-1] );
                
                if(isPalindrome[i][j] &amp;amp;&amp;amp; j-i+1 &amp;gt; maxLength){
                    maxLength = j-i+1;
                    startIndex = i;
                }
            }
        }
        result = s.substr(startIndex, maxLength);
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;The fill_n() function in C++ STL is used to fill some default values in a container. The fill_n() function is used to fill values upto first n positions from a starting position. It accepts an iterator begin and the number of positions n as arguments and fills the first n position starting from the position pointed by begin with the given value.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void fill_n(iterator begin, int n, type value);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;In the traversal process, variable j loops in the outer layer, while variable i loops in the inner layer. The reason is as follows.&lt;/p&gt;
&lt;p&gt;For example, when we want to the value of isPalindrome[2][7], we must know the value of isPalindrome[3][6] and isPalindrome[4][5], which means that we must traverse in the order of variable j.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;manachers-algorithm&#34;&gt;Manacher&amp;rsquo;s Algorithm&lt;/h2&gt;
&lt;h3 id=&#34;algorithm-1&#34;&gt;Algorithm&lt;/h3&gt;
&lt;p&gt;Firstly, we put aside even palindromes and focus on odd palindromes.&lt;/p&gt;
&lt;p&gt;Every palindrome has a center and a right boundary, and a distance between center and right boundary, which was described as the &amp;rsquo;expansion length&amp;rsquo; of a palindrome. In this algorithm, we create an array &lt;strong&gt;P[i]&lt;/strong&gt; to record the expansion length of an i-centered palindrome, and let Integer &lt;strong&gt;c&lt;/strong&gt; and &lt;strong&gt;r&lt;/strong&gt; to present the index of center and right boundary.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Eg: âabacabacabbâ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When going from left to right, when i is at index 3, the longest palindromic substring is âabacabaâ, P[3] = 3.&lt;/p&gt;
&lt;p&gt;Normally, we have to traverse from P[1] to P[string.length()-2], but we donât need to manually go to each index and expand to check the expansion length every time. This is exactly where Manacherâs algorithm optimizes better than brute force, by using some insights on how palindromes work. Letâs see how the optimization is done.&lt;/p&gt;
&lt;p&gt;When i = 4, the index is inside the scope of the current longest palindrome, i.e., i &amp;lt; r. So, instead of naively expanding at i, we want to know the minimum expansion length that is certainly possible at i, so that we can expand on that minimum P[i] and see, instead of doing from start. So, we check for mirror iâ.&lt;/p&gt;
&lt;p&gt;As long as the palindrome at index iâ does NOT expand beyond the left boundary (l) of the current longest palindrome, we can say that the minimum certainly possible expansion length at i is P[iâ].&lt;/p&gt;
&lt;p&gt;Remember that we are only talking about the minimum possible expansion length, the actual expansion length could be more and, weâll find that out by expanding later on. In this case, P[4] = P[2] = 0. We try to expand but still, P[4] remains 0.&lt;/p&gt;
&lt;p&gt;Now, if the palindrome at index iâ expands beyond the left boundary (l) of the current longest palindrome, we can say that the minimum certainly possible expansion length at i is r-i.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Eg: âacacacbâ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P[3] = 2&lt;/p&gt;
&lt;p&gt;P[2] = 2&lt;/p&gt;
&lt;p&gt;P[4] = 5â4 = 1&lt;/p&gt;
&lt;p&gt;You could ask but why canât the palindrome centered at i expand after r in this case? If it did, then it would have already been covered with the current center c only. But, it didnât. So, P[i] = r-i.&lt;/p&gt;
&lt;p&gt;So, we can sum the two situations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if(i&amp;gt;=right) {
    P[i] = 0;
}else{
    P[i] = min(P[MirrorIndex], right-i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;code-1&#34;&gt;Code&lt;/h3&gt;
&lt;p&gt;c++:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string longestPalindrome(string s) {
        string t;
        int i;
        for(i=0; i&amp;lt;s.length(); i++){
            t += &amp;quot;#&amp;quot;;
            t += s[i];
        }
        t+=&amp;quot;#&amp;quot;;
        
        vector&amp;lt;int&amp;gt; P(t.length(),0);
        int center = 0;
        int right = 0;
        int maxLen = 0;
        int resultCenter = 0;
        for(i=1; i&amp;lt;t.length()-1; i++){
            int MirrorIndex = center - (i-center);
            if(i&amp;gt;=right) {
                P[i] = 0;
            }else{
                P[i] = min(P[MirrorIndex], right-i);
            }
            
            while(i-1-P[i]&amp;gt;=0 &amp;amp;&amp;amp; i+1+P[i]&amp;lt;t.length() &amp;amp;&amp;amp; t[i-1-P[i]] == t[i+1+P[i]]){
                P[i]++;
            }
            
            if(i+P[i]&amp;gt;center){
                center = i;
                right = i+P[i];
            }
            if(P[i]&amp;gt;maxLen){
                maxLen = P[i];
                resultCenter = i;
            }
        }
        return s.substr((resultCenter - maxLen)/2, maxLen);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;references-and-websites&#34;&gt;References and Websites&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://medium.com/hackernoon/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Manacherâs Algorithm Explainedâ Longest Palindromic Substring&lt;/a&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
